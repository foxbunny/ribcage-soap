// Generated by CoffeeScript 1.6.3
/*!
@author Branko Vukelic <branko@brankovukelic.com>
@license MIT
*/

var _this = this;

if (typeof define !== 'function' || !define.amd) {
  this.require = function(dep) {
    return (function() {
      switch (dep) {
        case 'jquery':
          return _this.jQuery;
        case 'underscore':
          return _this._;
        case 'jquery.soap':
          return _this.jQuery.soap;
        case 'jquery.xml2json':
          return _this.jQuery.xml2json;
        default:
          return null;
      }
    })() || (function() {
      throw new Error("Unmet dependency " + dep);
    })();
  };
  this.define = function(factory) {
    return _this.ribcageSoap.mixin = factory(_this.require);
  };
}

define(function(require) {
  var $, _;
  $ = require('jquery');
  _ = require('underscore');
  require('jquery.soap');
  require('jquery.xml2json');
  return {
    baseUrl: 'http://example.com',
    namespace: 'http://example.com',
    debug: false,
    appendMethod: false,
    soap12: false,
    soapCreateMethod: 'Create',
    soapReadMethod: 'Read',
    soapUpdateMethod: 'Update',
    soapDeleteMethod: 'Delete',
    getSoapCreateMethod: function() {
      return this.soapCreateMethod;
    },
    getSoapReadMethod: function() {
      return this.soapReadMethod;
    },
    getSoapUpdateMethod: function() {
      return this.soapUpdateMethod;
    },
    getSoapDeleteMethod: function() {
      return this.soapDeleteMethod;
    },
    soapCreateTemplateSource: '',
    soapReadTemplateSource: '',
    soapUpdateTemplateSource: '',
    soapDeleteTemplateSource: '',
    soapGetCreateParams: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return _.extend({}, (model || this).toJSON(), params);
    },
    soapGetReadParams: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return _.extend({}, (model || this).toJSON(), params);
    },
    soapGetUpdateParams: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return _.extend({}, (model || this).toJSON(), params);
    },
    soapGetDeleteParams: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return _.extend({}, (model || this).toJSON(), params);
    },
    soapCreateTemplate: function(data) {
      return _.template(this.soapCreateTemplateSource, data);
    },
    soapReadTemplate: function(data) {
      return _.template(this.soapReadTemplateSource, data);
    },
    soapUpdateTemplate: function(data) {
      return _.template(this.soapUpdateTemplateSource, data);
    },
    soapDeleteTemplate: function(data) {
      return _.template(this.soapDeleteTemplateSource, data);
    },
    soapCreate: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return {
        method: this.getSoapCreateMethod(),
        params: this.soapCreateTemplate(this.soapGetCreateParams(model, params))
      };
    },
    soapRead: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return {
        method: this.getSoapReadMethod(),
        params: this.soapReadTemplate(this.soapGetReadParams(model, params))
      };
    },
    soapUpdate: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return {
        method: this.getSoapUpdateMethod(),
        params: this.soapUpdateTemplate(this.soapGetUpdateParams(model, params))
      };
    },
    soapDelete: function(model, params) {
      if (model == null) {
        model = null;
      }
      if (params == null) {
        params = null;
      }
      return {
        method: this.getSoapDeleteMethod(),
        params: this.soapDeleteTemplate(this.soapGetDeleteParams(model, params))
      };
    },
    getUrl: function(method, action) {
      return this.baseUrl;
    },
    getSoapActionName: function(method, soapMethod) {
      return "" + this.namespace + soapMethod;
    },
    sync: function(method, model, options) {
      var capMethod, fn, params;
      if (options == null) {
        options = {};
      }
      capMethod = "" + (method[0].toUpperCase()) + (method.slice(1));
      options.crudMethod = capMethod;
      fn = this["soap" + capMethod];
      params = fn.call(this, model, options.extraParams);
      return $.soap(_.extend(params, options, {
        enableLogging: this.debug,
        url: this.getUrl(method, params.method),
        appendMethodToURL: this.appendMethod,
        namespaceURL: this.namespace,
        SOAPAction: this.getSoapActionName(method, params.method),
        soap12: this.soap12
      }));
    },
    convertCreateResponse: function(json) {
      throw new Error('convertCreateResponse method is not implemented');
    },
    convertReadResponse: function(json) {
      throw new Error('convertReadResponse method is not implemented');
    },
    convertUpdateResponse: function(json) {
      throw new Error('convertUpdateResponse method is not implemented');
    },
    convertDeleteResponse: function(json) {
      throw new Error('convertDeleteResponse method is not implemented');
    },
    isDeleted: function(model) {
      return true;
    },
    convertResponse: function(json, options) {
      return this["convert" + options.crudMethod + "Response"](json);
    },
    parse: function(response, options) {
      return this.convertResponse(response.toJSON().Body, options);
    },
    destroy: function(options) {
      var error, success,
        _this = this;
      if (options == null) {
        options = {};
      }
      options = _.clone(options);
      options.parse || (options.parse = true);
      options.deleted || (options.deleted = this.isDeleted);
      success = options.success;
      options.success = function(resp) {
        if (!options.deleted(_this.set(_this.parse(resp, options), options))) {
          return false;
        }
        if (success) {
          success(_this, resp, options);
        }
        return _this.trigger('destroy', _this, _this.collection, options);
      };
      error = options.error;
      options.error = function(resp) {
        if (error) {
          error(_this, resp, options);
        }
        return _this.trigger('error', _this, resp, options);
      };
      return this.sync('delete', this, options);
    }
  };
});
